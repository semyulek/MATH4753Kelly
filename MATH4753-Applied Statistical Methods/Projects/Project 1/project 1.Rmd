---
title: "Project 1"
author: "Samuel Kelly"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    csl: biomed-central.csl
    df_print: paged
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    number_sections: yes
    theme: journal
    toc: yes
    toc_float: yes
  word_document:
    toc: yes
    toc_depth: '4'
  pdf_document:
    df_print: kable
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    highlight: tango
    toc: yes
    toc_depth: 4
#bibliography: project.bib
abstract: This project is all about analysing the SWDEFECTS file using R and probability theory. You will need to change the headings to reflect the nature of the project intentions. Re write this abstract as the last thing you do.
---

<center>

 ![Samuel Kelly](project_picture.jpg "My Picture"){ width=20% }

</center>


---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction to the data

## Data and variables(see MS pg. 77,125)
Describe the data and the problem we wish to investigate.

### Describe data

The SWDEFECTS.csv contains 498 different software codes, where each line of these 498 programs were assigned a value of true or false. False for correct, not defective code, and true for defective code.

### Problem to solve

Our goal is to find whether a piece of software code is defective.

## Summary Table 

Create the summary table (TABLE SIA3.2) found on page 125. You can use RMD code to do it -- see MARKDOWN QUICK REFERENCE in Rstudio help.

```{r}
sw.def <- read.csv("SWDEFECTS.csv")
tab <- table(sw.def$predict.loc.50, sw.def$defect)
tab
a = tab[1,1]

b = tab[1,2]

c = tab[2,1]

d = tab[2,2]

```

```
              Module has defects
         |-----------------------------|
         |False         | True         |
         |------------- | -------------|
Algorithm|a             | b            |
Predicts |c             | d            |
Defects  |-----------------------------|
```
### Make formulae 

Using $\LaTeX$ construct the formulae for 

1. Accuracy
$$P(Algorithm \: is \: correct) = \frac{(a+b)}{(a+b+c+d)}$$
2. Detection rate
$$P(predict \:defect| \: module \: has \: defect) = \frac{d}{(b+d)}$$
3. False alarm rate
$$P(predict \: defect|\: module \:has \:no \:defect)=\frac{c}{(a+c)}$$
4. Precision
$$P(module \: has \: defect| \: predict \: defect)=\frac{d}{(c+d)}$$

Latex Example: See (http://www.stat.cmu.edu/~cshalizi/rmarkdown/#elements-of-math-mode)

$$
\begin{eqnarray}
P(|X-\mu| > k) & = & P(|X-\mu|^2 > k^2)\\
& \leq & \frac{\mathbb{E}\left[|X-\mu|^2\right]}{k^2}\\
& \leq & \frac{\mathrm{Var}[X]}{k^2}
\end{eqnarray}
$$

# R functions
Using the above definitions make R functions that will create the required probabilities, please remove `eval=FALSE` when creating the functions :

```{r accuracy}
acc=function(a,b,c,d)
{
 (a + d)/(a + b + c + d)
}
```

```{r detecton}
detect=function(b,d)
{
  d / (b + d)
}
```

```{r alarm}
falarm=function(a,c)
{
  c / (a + c)
}
```

```{r precision}
prec=function(c,d)
{
  d / (c + d)
}
```


# Create the tables in Figure SIA3.1

The tables do not have to be formatted exactly as those in the book. Have the functions produce a suitable barplot also. 
In other words you will use R code to make these tables (again formatting does not have to be the same as the book)

As a guide and help -- see code below

```{r }
head(sw.def)
tab=with(sw.def, table(predict.loc.50,defect))
barplot(tab, beside=TRUE, leg=TRUE)
tab2=addmargins(tab)
tab2

tab=with(sw.def, table(predict.vg.10,defect))
barplot(tab, beside=TRUE, leg=TRUE)
tab2=addmargins(tab)
tab2

tab=with(sw.def, table(predict.evg.14.5,defect))
barplot(tab, beside=TRUE, leg=TRUE)
tab2=addmargins(tab)
tab2

tab=with(sw.def, table(predict.ivg.9.2,defect))
barplot(tab, beside=TRUE, leg=TRUE)
tab2=addmargins(tab)
tab2

```





# Create the corrected table on page 127 (there are mistakes in it), TABLE SIA3.3

Using the functions you have made **or otherwise**, create the corrected table (SIA3.3) in an R chunk -- that is, you will make an R function to create the table.
 
You can call this table `tab3`

```{r Probability measures}
prob.meas=function(tab)
{
  a = tab[1,1]

  b = tab[1,2]

  c = tab[2,1]

  d = tab[2,2]
  
  measures <- c(acc(a = a,b = b,c = c,d = d),
  detect(b = b,d = d),
  falarm(a = a,c = c),
  prec(c = c,d = d))
}
```

```{r}
tab <- table(sw.def$predict.loc.50, sw.def$defect)
loc.meas<-prob.meas(tab = tab)

tab <- table(sw.def$predict.vg.10, sw.def$defect)
cyclo.meas <- prob.meas(tab = tab)

tab <- table(sw.def$predict.evg.14.5, sw.def$defect)
essential.meas <- prob.meas(tab = tab)

tab <- table(sw.def$predict.ivg.9.2, sw.def$defect)
design.meas <- prob.meas(tab = tab)

accuracy<-c(loc.meas[1],cyclo.meas[1],essential.meas[1],design.meas[1])
detection<-c(loc.meas[2],cyclo.meas[2],essential.meas[2],design.meas[2])
false.alarm<-c(loc.meas[3],cyclo.meas[3],essential.meas[3],design.meas[3])
precision<-c(loc.meas[4],cyclo.meas[4],essential.meas[4],design.meas[4])
```

```{r Table}
prob.df.1 <- data.frame(accuracy,detection,false.alarm,precision)
prob.df.2 <- data.frame(loc.meas,cyclo.meas,essential.meas,design.meas)
measure.name<-c("Accuracy", "Detection", "False Alarm", "Precision")
detect.names<-c("Lines of code", "Cyclomatic", "Essential", "Design")
rownames(prob.df.1)<-c("Lines of code", "Cyclomatic", "Essential", "Design")

test.df<-data.frame(matrix(ncol = 4,nrow = 4))
test.df[1,]=loc.meas
test.df[2,]=cyclo.meas
test.df[3,]=essential.meas
test.df[4,]=design.meas
names(test.df)<-measure.name
rownames(test.df)<-detect.names
test.df

list(test.df)

names(prob.df.1)<-c("Accuracy", "Detection", "False Alarm", "Precision")
round(prob.df.1, 3)
names(prob.df.1)
with(prob.df.1, xtabs())
```

Now create a function `mybar()`that will have as its input variables

>
    1. tab ( this will be a n by m table) - like `tab3`
    2. dec ( accuracy of the decimal output ) -- like `dec=4` for example would mean 4 decimal places (use `round()`)
    

    
The function will need to create two things

>
    1. A barplot of the table
    2. Commandline output in the form of a list containing the table


```{r}
mybar<-function(dec){
  barplot(t(as.matrix(prob.df.2)),beside = TRUE,
          legend.text = c("Lines of code", "Cyclomatic", "Essential", "Design"),col=c("red","green","blue","purple"))
  list(round(prob.df.1,dec))
}
```

```{r}
mybar(3)
```


